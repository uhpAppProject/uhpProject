'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseIcons = undefined;

var _getIterator2;

function _load_getIterator() {
  return _getIterator2 = _interopRequireDefault(require('babel-runtime/core-js/get-iterator'));
}

var _promise;

function _load_promise() {
  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));
}

var _toConsumableArray2;

function _load_toConsumableArray() {
  return _toConsumableArray2 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));
}

var _objectWithoutProperties2;

function _load_objectWithoutProperties() {
  return _objectWithoutProperties2 = _interopRequireDefault(require('babel-runtime/helpers/objectWithoutProperties'));
}

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require('babel-runtime/regenerator'));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));
}

var getBufferWithMimeAsync = function () {
  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(_ref2, mimeType, _ref3) {
    var src = _ref2.src,
        resizeMode = _ref2.resizeMode,
        color = _ref2.color;
    var width = _ref3.width,
        height = _ref3.height;
    var imagePath;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            imagePath = void 0;

            if (supportedMimeTypes.includes(mimeType)) {
              _context.next = 5;
              break;
            }

            imagePath = src;
            _context.next = 8;
            break;

          case 5:
            _context.next = 7;
            return resize(src, mimeType, width, height, resizeMode, color);

          case 7:
            imagePath = _context.sent;

          case 8:
            _context.prev = 8;
            _context.next = 11;
            return (_fsExtra || _load_fsExtra()).default.readFile(imagePath);

          case 11:
            return _context.abrupt('return', _context.sent);

          case 14:
            _context.prev = 14;
            _context.t0 = _context['catch'](8);
            throw new (_IconError || _load_IconError()).default('It was not possible to read \'' + src + '\'.');

          case 17:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[8, 14]]);
  }));

  return function getBufferWithMimeAsync(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

var processImage = function () {
  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee2(size, icon, fingerprint, publicPath) {
    var _parseSize, width, height, mimeType, _buffer;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _parseSize = parseSize(size), width = _parseSize.width, height = _parseSize.height;

            if (!(width <= 0 || height <= 0)) {
              _context2.next = 3;
              break;
            }

            return _context2.abrupt('return');

          case 3:
            mimeType = (_mime || _load_mime()).default.getType(icon.src);
            _context2.next = 6;
            return getBufferWithMimeAsync(icon, mimeType, { width: width, height: height });

          case 6:
            _buffer = _context2.sent;
            return _context2.abrupt('return', processIcon(width, height, icon, _buffer, mimeType, publicPath, fingerprint));

          case 8:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function processImage(_x4, _x5, _x6, _x7) {
    return _ref4.apply(this, arguments);
  };
}();

var resize = function () {
  var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee3(inputPath, mimeType, width, height) {
    var fit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'contain';
    var background = arguments[5];
    var outputPath, message;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            outputPath = (_tempy || _load_tempy()).default.directory();
            _context3.next = 4;
            return (0, (_imageUtils || _load_imageUtils()).sharpAsync)({
              input: inputPath,
              output: outputPath,
              format: mimeType.split('/')[1]
            }, [{
              operation: 'resize',
              width: width,
              height: height,
              fit: fit,
              background: background
            }]);

          case 4:
            return _context3.abrupt('return', _path.default.join(outputPath, _path.default.basename(inputPath)));

          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3['catch'](0);
            message = _context3.t0.message;
            throw new (_IconError || _load_IconError()).default('It was not possible to generate splash screen \'' + inputPath + '\'. ' + message);

          case 11:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this, [[0, 7]]);
  }));

  return function resize(_x8, _x9, _x10, _x11) {
    return _ref5.apply(this, arguments);
  };
}();

var parseIcons = exports.parseIcons = function () {
  var _ref7 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee5(inputIcons, fingerprint, publicPath) {
    var _this = this;

    var icons, assets, promises, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (inputIcons.length) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt('return', {});

          case 2:
            icons = [];
            assets = [];
            promises = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context5.prev = 8;

            _loop = function _loop() {
              var icon = _step.value;
              var sizes = icon.sizes;

              promises = [].concat((0, (_toConsumableArray2 || _load_toConsumableArray()).default)(promises), (0, (_toConsumableArray2 || _load_toConsumableArray()).default)(sizes.map(function () {
                var _ref10 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee4(size) {
                  var _ref11, manifestIcon, webpackAsset;

                  return (_regenerator || _load_regenerator()).default.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          _context4.next = 2;
                          return processImage(size, icon, fingerprint, publicPath);

                        case 2:
                          _ref11 = _context4.sent;
                          manifestIcon = _ref11.manifestIcon;
                          webpackAsset = _ref11.webpackAsset;

                          icons.push(manifestIcon);
                          assets.push(webpackAsset);

                        case 7:
                        case 'end':
                          return _context4.stop();
                      }
                    }
                  }, _callee4, _this);
                }));

                return function (_x16) {
                  return _ref10.apply(this, arguments);
                };
              }())));
            };

            for (_iterator = (0, (_getIterator2 || _load_getIterator()).default)(inputIcons); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              _loop();
            }
            _context5.next = 17;
            break;

          case 13:
            _context5.prev = 13;
            _context5.t0 = _context5['catch'](8);
            _didIteratorError = true;
            _iteratorError = _context5.t0;

          case 17:
            _context5.prev = 17;
            _context5.prev = 18;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 20:
            _context5.prev = 20;

            if (!_didIteratorError) {
              _context5.next = 23;
              break;
            }

            throw _iteratorError;

          case 23:
            return _context5.finish(20);

          case 24:
            return _context5.finish(17);

          case 25:
            _context5.next = 27;
            return (_promise || _load_promise()).default.all(promises);

          case 27:
            return _context5.abrupt('return', {
              icons: icons.filter(function (icon) {
                return icon;
              }).sort(function (_ref8, _ref9) {
                var sizes = _ref8.sizes;
                var sizesB = _ref9.sizes;

                if (sizes < sizesB) return -1;else if (sizes > sizesB) return 1;
                return 0;
              }),
              // startupImages: icons.filter(({ isStartupImage }) => isStartupImage),
              assets: assets
            });

          case 28:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, this, [[8, 13, 17, 25], [18,, 20, 24]]);
  }));

  return function parseIcons(_x13, _x14, _x15) {
    return _ref7.apply(this, arguments);
  };
}();

exports.retrieveIcons = retrieveIcons;

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _mime;

function _load_mime() {
  return _mime = _interopRequireDefault(require('mime'));
}

var _path = _interopRequireDefault(require('path'));

var _tempy;

function _load_tempy() {
  return _tempy = _interopRequireDefault(require('tempy'));
}

var _imageUtils;

function _load_imageUtils() {
  return _imageUtils = require('@expo/image-utils');
}

var _uri;

function _load_uri() {
  return _uri = require('./helpers/uri');
}

var _fingerprint;

function _load_fingerprint() {
  return _fingerprint = _interopRequireDefault(require('./helpers/fingerprint'));
}

var _IconError;

function _load_IconError() {
  return _IconError = _interopRequireDefault(require('./errors/IconError'));
}

var _Apple;

function _load_Apple() {
  return _Apple = require('./validators/Apple');
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supportedMimeTypes = ['image/png', 'image/jpeg', 'image/webp'];

function parseArray(i) {
  if (i == null) return [];
  return i && !Array.isArray(i) ? [i] : i;
}

function sanitizeIcon(iconSnippet) {
  if (!iconSnippet.src) {
    throw new (_IconError || _load_IconError()).default('Unknown icon source.');
  }
  var sizes = parseArray(iconSnippet.size || iconSnippet.sizes);
  if (!sizes) {
    throw new (_IconError || _load_IconError()).default('Unknown icon sizes.');
  }
  return {
    src: iconSnippet.src,
    resizeMode: iconSnippet.resizeMode,
    sizes: sizes,
    media: iconSnippet.media,
    destination: iconSnippet.destination,
    ios: iconSnippet.ios || false,
    color: iconSnippet.color
  };
}

function processIcon(width, height, icon, buffer, mimeType, publicPath, shouldFingerprint) {
  var dimensions = width + 'x' + height;
  var fileName = shouldFingerprint ? 'icon_' + dimensions + '.' + (0, (_fingerprint || _load_fingerprint()).default)(buffer) + '.' + (_mime || _load_mime()).default.getExtension(mimeType) : 'icon_' + dimensions + '.' + (_mime || _load_mime()).default.getExtension(mimeType);
  var iconOutputDir = icon.destination ? (0, (_uri || _load_uri()).joinURI)(icon.destination, fileName) : fileName;
  var iconPublicUrl = (0, (_uri || _load_uri()).joinURI)(publicPath, iconOutputDir);

  var manifestIcon = null;
  if (width === height) {
    manifestIcon = {
      src: iconPublicUrl,
      sizes: dimensions,
      type: mimeType
    };
  }
  return {
    manifestIcon: manifestIcon,
    webpackAsset: {
      output: iconOutputDir,
      url: iconPublicUrl,
      source: buffer,
      size: buffer.length,
      ios: icon.ios ? { valid: icon.ios, media: icon.media, size: dimensions, href: iconPublicUrl } : false,
      resizeMode: icon.resizeMode,
      color: icon.color
    }
  };
}

function parseSize(size) {
  var width = void 0;
  var height = void 0;
  if (Array.isArray(size) && size.length) {
    // [0, 0] || [0]
    width = size[0];
    height = size.length > 1 ? size[1] : size[0];
  } else if (typeof size === 'number') {
    // 0
    width = size;
    height = size;
  } else if (typeof size === 'string') {
    // '0x0'
    var dimensions = size.split('x');
    width = dimensions[0];
    height = dimensions[1];
  }
  return { width: width, height: height };
}

function retrieveIcons(manifest) {
  // Remove these items so they aren't written to disk.
  var startupImages = manifest.startupImages,
      icons = manifest.icons,
      config = (0, (_objectWithoutProperties2 || _load_objectWithoutProperties()).default)(manifest, ['startupImages', 'icons']);

  var parsedStartupImages = parseArray(startupImages);

  var parsedIcons = parseArray(icons);

  if (parsedStartupImages.length) {
    // TODO: Bacon: use all of the startup images
    var startupImage = parsedStartupImages[0];
    parsedIcons = [].concat((0, (_toConsumableArray2 || _load_toConsumableArray()).default)(parsedIcons), (0, (_toConsumableArray2 || _load_toConsumableArray()).default)((0, (_Apple || _load_Apple()).fromStartupImage)(startupImage)));
  }

  var response = parsedIcons.map(function (icon) {
    return sanitizeIcon(icon);
  });
  return [response, config];
}
//# sourceMappingURL=__sourcemaps__/icons.js.map
